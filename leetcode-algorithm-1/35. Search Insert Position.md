# 35. Search Insert Position
- https://leetcode.com/problems/search-insert-position/description/
- Beats 99.89%, Memory 42.3 MB

# Intuition

<!-- Describe your first thoughts on how to solve this problem. -->

- target과 동일한 값이 없다면, 들어갔어야 하는 위치를 찾아야 한다.

# Approach

<!-- Describe your approach to solving the problem. -->

- [left, right]는 inclusive이다. 따라서 left는 배열의 시작인 0이고, right는 배열의 마지막인 nums.length -1이다. mid는 Math.floor((left + right)/2)이다.
- mid에 있는 값과 비교했을 때, target이 작거나 같으면, 윈도우를 왼쪽으로 옮겨야 한다. 이 때, mid가 target이 위치할 인덱스가 될 수 있으므로, right = mid로 둔다.
- mid에 있는 값과 비교했을 때, target이 크면, 윈도우를 오른쪽으로 옮겨야 한다. left는 mid+1로 둔다.
- 종료 조건 : left와 right가 만나면, 종료한다.
- 종료 조건 : left에 위치한 값이 target보다 크거나 같으면, target이 위치할 곳이다. 이때는 left를 반환한다. left에 위치한 값이 target보다 작으면, target은 left+1에 위치해야 한다.

# Complexity

- Time complexity: O(log n) : 매 순회마다, 배열의 크기를 반으로 줄인다.
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity: O(1)
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

# Code

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */

const searchInsert = function (nums, target) {
  let left = 0;
  let right = nums.length - 1;

  while (left < right) {
    const mid = Math.floor((left + right) / 2);
    const check = nums[mid];
    if (check >= target) {
      right = mid;
    } else {
      left = mid + 1;
    }
  }

  return nums[left] >= target ? left : left + 1;
};
```
